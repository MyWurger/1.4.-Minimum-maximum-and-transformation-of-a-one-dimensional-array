/*******************************************************************************
 *          Л А Б О Р А Т О Р Н А Я    Р А Б О Т А   № 4     С  +  +           *
 *-----------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                   *
 * Project Name  : Лаборатораная работа 4                                      *
 * File Name     : Вариант1.CPP                                                *
 * Programmer(s) : Викулов Д.Г.                                                *
 * Modifyed By   :                                                             *
 * Created       : 9/12/21                                                     *
 * Last Revision : 19/12/21                                                    *
 * Comment(s)    : Получает на вход массив из файла. Ищет минимальный и        *
 *                максимальный элементы. Выполняет над ним указанные операции. *
 *******************************************************************************/

#include <iostream> //стандартные потоки ввода/вывода
#include <fstream>  //файловые потоки ввода/вывода
using namespace std; // используем пространство имён std
//const char* FNAME = "Correct_data_udal1.txt"; // запоминаем путь к файлу через константную переменную для удобства тестов
const int LEN_MAX = 40; // неизменяемая максимальная длина массива. Взял такую, чтобы наверняка (до 20 элементов массива)

/*******************************************************************/
/*                    Н А Б О Р    Т Е С Т О В                     */
/*******************************************************************/

//const char* FNAME = "Faila_net.txt";
//const char* FNAME = "Pustota.txt";
//const char* FNAME = "Num_ne_chislo.txt";
//const char* FNAME = "Num_Less_0.txt";
//const char* FNAME = "V_Massive_Ne_Chislo.txt";
//const char* FNAME = "Chislo_elementov_ravno_LEN_MAX_del_2.txt";
//const char* FNAME = "Chislo_elementov_bigger_LEN_MAX_del_2.txt";
//const char* FNAME = "i_Ne_Ravno_Num.txt";
//const char* FNAME = "Odinakovue.txt";
const char* FNAME = "Correct_data_udal2.txt";
//const char* FNAME = "Correct_data_udal3.txt";
//const char* FNAME = "Correct_data_udal4.txt";
//const char* FNAME = "Dublir_vse_otricat.txt";
//const char* FNAME = "Dublir_vse_polog.txt";
//const char* FNAME = "Dublir_cheredovanie.txt";
//const char* FNAME = "Dublir_est_nol.txt";

/*******************************************************************/
/*               О С Н О В Н А Я     П Р О Г Р А М М А             */
/*******************************************************************/
int main()
{ //начало main
	system("color F0"); // делаем консоль светлой
	setlocale(LC_ALL, "Rus"); // подключаем русский язык
	system("cls"); // чистим консоль перед выводом
	int Num; // реальное число элементов в массиве
	int i = 0; // индексная переменная. Отвечает за проход по индексам
	int j = 0; // индексная переменная-счётчик
	int max; // переменная отвечает за поиск самого max
	int min; // переменная отвечает за поиск самого min
	int imax; // переменная отверчает за поиск индекса max
	int imin; // переменная отвечает за поиск индекса min
	int LineVec; // переменная, отвечающая за сдвиги
	int AVec[LEN_MAX]; // массив, отвечающий за считывание элементов из файла
	ifstream fin; // объявление объекта для потокового введения данных из файла
	fin.open(FNAME); // связываем обЪект с файлом. Открываем для чтания
	// проверки на ошибки файла
	fin >> Num; // считали третье число из файла
	LineVec = Num;
	cout << "Число элементов в массиве из файла: " << Num << endl; // эхо-печать
	if (!fin.is_open()) //файл не найден
	{
		cout << "Файл " << FNAME << " не найден\n";
		fin.close();      //закрыть файл
		system("pause");
		return 1;         //выход по ошибке
	}
	// файл существует, можно из него читать
	// проверки состояния файла
	if (fin.eof()) // файл пуст
	{
		cout << "Файл " << FNAME << " пустой\n";
		fin.close();    //закрыть файл
		system("pause");
		return 2; //выход по ошибке
	}
	if (fin.fail()) //в файле не число (проверяет по первому элементу строки)
	{
		cout << "Ошибка! В файле " << FNAME << " не число\n\n";
		fin.close();    //закрыть файл
		system("pause");
		return 3;   //выход по ошибке
	}
	cout << "\n\t\tЧтение элементов из файла " << FNAME << "\n\n";
	// к данному моменту в файле остался только наша строка-массив

	while (!fin.eof()) // пока не закончился файл
	{
		fin >> AVec[i]; // считываем данный элемент и присваиваем AVec[i]
		//INT_MIN - минимальное значение для переменной типа INT
		//INT_MAX - максимальное значение для переменной типа INT
		if (fin.fail()) // проверка на нечисло в самом массиве (на соответствие типов данных)
		{
			cout << "ОШИБКА! Среди элементов массива " << FNAME << " есть нечисло" << endl;
			fin.close(); // закрыть файл
			system("pause");
			return 4; // выход по ошибке
		}
		if (i > LEN_MAX/2) // если количество элементов в массиве половины, то не сможем удвоить
		{
			cout << "Ошибка! Число элементов в файле " << FNAME << " больше допустимого\n";
			fin.close(); // закрыть файл
			return 5; // выход по ошибке
		}
		cout << "1. i = " << i << "\tAVec[" << i
			<< "] = " << AVec[i]
			<< "\tfin.eof() = " << fin.eof()  // эхо-печать считанного массива
			<< "\tfin.good() = " << fin.good() << endl;

		i = i + 1; // увеличиваем счётчик
	}//Конец while
	if (i != Num) // количество элементов массива не совпадает с объявленным
	{
		cout << "Число элементов в файле " << FNAME << " не совпадает с введённым\n";
		system("pause");
		fin.close(); // закрыть файл
		return 6; // выход по ошибке
	}
	cout << endl;
	cout << "Чтение файла OK\n\n";
	fin.close(); //закрытие файла исходных данных

	//	ОСНОВНОЙ АЛГОРИТМ ПРОГРАММЫ
	max = AVec[0]; // берём за максимальный первый элемент массива  
	min = AVec[0]; // берем за минимальный первый элемент массива
	imax = 0; // берём за минимальный индекс первого элемента
	imin = 0; // берём за максимальный индекс первого элемента

	// поиск максимального элемента и его индекса

	for (i = 1; i < Num; i++) //начало for, движения по остаточной части массива
	{
		if (AVec[i] > max) //Больше ли следующий элемент чем max
		{
			max = AVec[i]; // Максимальный элемент равен текущему
			imax = i; //Задание индекса текущего элемента
		}
	} //Конец for

	// поиск минимального элемента и его индекса

	for (i = 1; i < Num; i++) //начало for, движения по остаточной части массива
	{
		if (AVec[i] < min) //Меньше ли следующий элемент чем min
		{
			min = AVec[i]; // Минимальный элемент равен текущему
			imin = i; //Задание индекса текущего элемента
		}
	} //Конец for

	// вывод минимального и максимального элемента для проверки
	cout << "Наибольший элемент массива: " << max << "\nЕго индекс: " << imax << endl << endl;
	cout << "Наменьший элемент массива: " << min << "\nЕго индекс: " << imin << endl;
	// если массив состоит из одинаковых элементов
	if (imin == imax) // imin и imax остаётся нулевым индексом
	{
		cout << "ОШИБКА! В массиве все элементы одинаковые\n";
		system("pause");
		return 7; // выходим. Продолжать смысла нет
	} // конец if
	if (imin < imax) // минимальный элемент стоит левее максимального
	{
		for (i = 0; i < imin; i++) // идём до индекса минимального элемента
		{
			if (AVec[i] > 0) // если элемент массива положителен, то удаляем его
			{
				for (j = i; j < LineVec; j++) // начинаем c i-го. Идём по всем элементам массива с учётом смещения 
				{
					AVec[j] = AVec[j + 1]; // присваиваем предыдущему следующий, чтобы сместить положительный элемент
				} // конец for
				LineVec = LineVec -1; // уменьшаем на единицу настоящие количество элементов массива, т.к один вылетел
				i = i-1; // уменьшаем на единицу счётчик, т.к число элементов уменьшилось
				imin = imin -1; // уменьшаем на единицу идекс минимального элемента, так как он сдвинулся на 1 влево
			} // конец if
		}// конец for

		cout << "Новый массив: \n";
		for (i = 0; i < LineVec; i++)
		{
			cout << AVec[i] << " "; // выводим результат
		} // конец for
	}
	else // если минимальный правее максимального
	{	
		for (i = imin+1; i < LineVec; i = i + 2) // начинаем с индекса следующего за индексом минимального по меняющийся конец. Перескакиваем с интервалом 2, чтобы не дублировать одно и то же
		{
			if (AVec[i] > 0) // если элемент положительный
			{
				for (j = LineVec - 1; j >= i; j = j - 1) // начинаем с индекса последнего по i-ый с уменьшением
				{
					AVec[j + 1] = AVec[j]; // присваиваем следующему элементу предыдущий, т.е последний будет каждый проход уходить правее в запас Len_Max
				} // конец for
				LineVec++;//увеличиваем на единицу настоящие количество элементов массив
			}
			else
			{
				i = i - 1; //если элемент отрицателен, то скачем на единицу, чтобы не пропустить вдруг следующий положительный
			} // конец if
		} // конец for
		cout << "Новый массив: \n";
		for (i = 0; i < LineVec; i++)
		{
			cout << AVec[i] << " "; // в этом случае тоже выводим массив до нашего нового количества элементов
		} // конец for
	} // конец if
	cout << endl;
	system("pause");
	return 0;
} // конец main